<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>‰∏ÉÈæôÁè†ÂºπÁêÉ - Dragon Ball Breakout</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: #050510;
      background-image:
        radial-gradient(ellipse at 30% 20%, rgba(180, 80, 0, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 80%, rgba(20, 40, 120, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(200, 100, 0, 0.05) 0%, transparent 60%);
      font-family: 'Orbitron', sans-serif;
      color: #e8f3ff;
      user-select: none;
      overflow: hidden;
    }

    .wrap {
      width: min(96vw, 1020px);
      display: grid;
      gap: 10px;
      position: relative;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 20px;
      border-radius: 12px;
      background: rgba(10, 12, 25, 0.85);
      border: 1px solid rgba(255, 180, 50, 0.15);
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5);
      font-size: 12px;
      letter-spacing: 1.2px;
      text-transform: uppercase;
    }

    .hud-left {
      display: flex;
      gap: 24px;
    }

    .hud-item .label {
      color: rgba(255, 200, 100, 0.6);
      font-size: 10px;
    }

    .hud-item .value {
      color: #ffcc33;
      font-weight: 700;
      font-size: 14px;
      text-shadow: 0 0 8px rgba(255, 180, 50, 0.4);
    }

    #status {
      color: rgba(255, 200, 120, 0.7);
      font-size: 11px;
    }

    canvas {
      width: 100%;
      aspect-ratio: 16 / 9;
      display: block;
      border-radius: 12px;
      border: 2px solid rgba(255, 180, 50, 0.12);
      box-shadow:
        0 0 40px rgba(255, 150, 0, 0.08),
        0 16px 48px rgba(0, 0, 0, 0.5),
        inset 0 0 1px rgba(255, 255, 255, 0.05);
      cursor: crosshair;
    }

    .back-btn {
      position: absolute;
      top: -40px;
      right: 0;
      background: rgba(10, 15, 30, 0.7);
      border: 1px solid rgba(255, 180, 50, 0.2);
      color: rgba(255, 200, 120, 0.7);
      padding: 6px 14px;
      border-radius: 6px;
      font-family: 'Orbitron', sans-serif;
      font-size: 10px;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.3s;
      letter-spacing: 1px;
    }

    .back-btn:hover {
      background: rgba(60, 40, 10, 0.5);
      border-color: rgba(255, 180, 50, 0.4);
      color: #ffcc33;
    }
  </style>
</head>

<body>
  <main class="wrap">
    <a class="back-btn" href="/custom_pages/games.html">‚óÄ BACK</a>
    <div class="hud">
      <div class="hud-left">
        <div class="hud-item">
          <span class="label">SCORE </span>
          <span class="value" id="score">0</span>
        </div>
        <div class="hud-item">
          <span class="label">BRICKS </span>
          <span class="value" id="remain">0</span>
        </div>
        <div class="hud-item">
          <span class="label">COMBO </span>
          <span class="value" id="combo">x1</span>
        </div>
      </div>
      <div id="status">ÁßªÂä®Èº†Ê†áÊéßÂà∂Êå°Êùø ¬∑ Â∑¶ÈîÆÂèëÂ∞ÑÈæôÁè†</div>
    </div>
    <canvas id="game" width="960" height="540" aria-label="‰∏ÉÈæôÁè†ÂºπÁêÉÊâìÁ†ñÂùó"></canvas>
  </main>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const remainEl = document.getElementById("remain");
    const scoreEl = document.getElementById("score");
    const comboEl = document.getElementById("combo");

    const W = canvas.width;
    const H = canvas.height;

    // Load Dragon Ball sprite
    const dragonBallImg = new Image();
    dragonBallImg.src = "dragon-ball-sphere.png";
    let imgLoaded = false;
    dragonBallImg.onload = () => { imgLoaded = true; };

    const paddle = {
      width: 160, height: 16,
      x: W / 2 - 80, y: H - 48,
      targetX: W / 2 - 80,
      speedFollow: 0.18
    };

    const levelConfig = {
      rows: 7, cols: 12,
      brickW: 68, brickH: 22,
      gap: 6, offsetTop: 48
    };

    const balls = [];
    const bricks = [];
    const explosions = [];
    const shockwaves = [];
    const trailParticles = [];

    let running = false;
    let won = false;
    let lost = false;
    let mouseX = W / 2;
    let lastTime = performance.now();
    let score = 0;
    let combo = 0;
    let comboTimer = 0;
    let screenShake = 0;
    let bgStars = [];

    // Initialize background stars
    for (let i = 0; i < 80; i++) {
      bgStars.push({
        x: Math.random() * W,
        y: Math.random() * H,
        size: Math.random() * 1.5 + 0.3,
        alpha: Math.random() * 0.5 + 0.1,
        twinkleSpeed: Math.random() * 0.03 + 0.01
      });
    }

    // Color palette for bricks - Dragon Ball themed
    const BRICK_COLORS = [
      { fill: '#ff4444', glow: 'rgba(255,68,68,0.4)', highlight: '#ff8888' },
      { fill: '#ff8800', glow: 'rgba(255,136,0,0.4)', highlight: '#ffbb44' },
      { fill: '#ffcc00', glow: 'rgba(255,204,0,0.4)', highlight: '#ffee66' },
      { fill: '#44cc44', glow: 'rgba(68,204,68,0.4)', highlight: '#88ee88' },
      { fill: '#4488ff', glow: 'rgba(68,136,255,0.4)', highlight: '#88bbff' },
      { fill: '#cc44ff', glow: 'rgba(204,68,255,0.4)', highlight: '#dd88ff' },
      { fill: '#ff4488', glow: 'rgba(255,68,136,0.4)', highlight: '#ff88bb' },
    ];

    function createBall(x, y, vx, vy) {
      balls.push({
        x, y, vx, vy,
        r: 12,
        trail: [],
        rotation: 0,
        rotSpeed: (Math.random() - 0.5) * 10
      });
    }

    function resetLevel() {
      balls.length = 0;
      bricks.length = 0;
      explosions.length = 0;
      shockwaves.length = 0;
      trailParticles.length = 0;
      running = false;
      won = false;
      lost = false;
      score = 0;
      combo = 0;
      comboTimer = 0;
      scoreEl.textContent = '0';
      comboEl.textContent = 'x1';

      const totalW = levelConfig.cols * levelConfig.brickW + (levelConfig.cols - 1) * levelConfig.gap;
      const startX = (W - totalW) / 2;

      for (let row = 0; row < levelConfig.rows; row++) {
        for (let col = 0; col < levelConfig.cols; col++) {
          const colorSet = BRICK_COLORS[row % BRICK_COLORS.length];
          bricks.push({
            x: startX + col * (levelConfig.brickW + levelConfig.gap),
            y: levelConfig.offsetTop + row * (levelConfig.brickH + levelConfig.gap),
            w: levelConfig.brickW,
            h: levelConfig.brickH,
            alive: true,
            color: colorSet.fill,
            glow: colorSet.glow,
            highlight: colorSet.highlight,
            hp: row === 0 ? 2 : 1,
            maxHp: row === 0 ? 2 : 1,
            hitFlash: 0
          });
        }
      }

      statusEl.textContent = "ÁßªÂä®Èº†Ê†áÊéßÂà∂Êå°Êùø ¬∑ Â∑¶ÈîÆÂèëÂ∞ÑÈæôÁè†";
      updateRemainText();
    }

    function updateRemainText() {
      const left = bricks.filter(b => b.alive).length;
      remainEl.textContent = left;
    }

    function launchBall() {
      if (running || won || lost) return;
      createBall(
        paddle.x + paddle.width / 2,
        paddle.y - 14,
        (Math.random() * 2 - 1) * 140,
        -380
      );
      running = true;
      statusEl.textContent = "ÈæôÁè†Â∑≤ÂèëÂ∞ÑÔºÅ";
    }

    function restartAfterEnd() {
      if (!won && !lost) return;
      resetLevel();
    }

    function spawnExplosion(x, y, color, count = 22) {
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count + Math.random() * 0.4;
        const speed = 80 + Math.random() * 220;
        explosions.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0.5 + Math.random() * 0.3,
          maxLife: 0.5 + Math.random() * 0.3,
          size: 2.5 + Math.random() * 4,
          color
        });
      }
    }

    function spawnShockwave(x, y, color) {
      shockwaves.push({ x, y, radius: 0, maxRadius: 60, life: 0.4, maxLife: 0.4, color });
    }

    function resolveBallBrickCollision(ball, brick) {
      const nearestX = Math.max(brick.x, Math.min(ball.x, brick.x + brick.w));
      const nearestY = Math.max(brick.y, Math.min(ball.y, brick.y + brick.h));
      const dx = ball.x - nearestX;
      const dy = ball.y - nearestY;

      if (dx * dx + dy * dy > ball.r * ball.r) return false;

      const overlapLeft = ball.x + ball.r - brick.x;
      const overlapRight = brick.x + brick.w - (ball.x - ball.r);
      const overlapTop = ball.y + ball.r - brick.y;
      const overlapBottom = brick.y + brick.h - (ball.y - ball.r);
      const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

      if (minOverlap === overlapLeft || minOverlap === overlapRight) {
        ball.vx *= -1;
      } else {
        ball.vy *= -1;
      }

      brick.hp--;
      brick.hitFlash = 8;
      screenShake = 4;

      if (brick.hp <= 0) {
        brick.alive = false;
        const cx = brick.x + brick.w / 2;
        const cy = brick.y + brick.h / 2;
        spawnExplosion(cx, cy, brick.color, 18);
        spawnShockwave(cx, cy, brick.color);

        // Scoring with combo
        comboTimer = 60;
        combo++;
        const points = 100 * combo;
        score += points;
        scoreEl.textContent = score;
        comboEl.textContent = `x${combo}`;
        comboEl.style.textShadow = `0 0 12px rgba(255, 180, 50, ${Math.min(combo * 0.2, 1)})`;

        updateRemainText();
        if (bricks.every(b => !b.alive)) {
          running = false;
          won = true;
          statusEl.textContent = "üêâ ËÉúÂà©ÔºÅÈõÜÈΩêÈæôÁè†ÔºÅÂ∑¶ÈîÆÈáçÊñ∞ÂºÄÂßã";
          screenShake = 12;
        }
      }

      return true;
    }

    function update(dt) {
      // Smooth paddle follow
      paddle.targetX = mouseX - paddle.width / 2;
      paddle.x += (paddle.targetX - paddle.x) * paddle.speedFollow;
      paddle.x = Math.max(0, Math.min(W - paddle.width, paddle.x));

      // Combo timer
      if (comboTimer > 0) {
        comboTimer--;
        if (comboTimer === 0) {
          combo = 0;
          comboEl.textContent = 'x1';
          comboEl.style.textShadow = '';
        }
      }

      // Screen shake decay
      if (screenShake > 0) screenShake *= 0.85;
      if (screenShake < 0.1) screenShake = 0;

      // Stars twinkling
      bgStars.forEach(s => {
        s.alpha = 0.1 + Math.abs(Math.sin(performance.now() * s.twinkleSpeed)) * 0.4;
      });

      if (running) {
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          ball.x += ball.vx * dt;
          ball.y += ball.vy * dt;
          ball.rotation += ball.rotSpeed * dt;

          // Dragon ball trail
          ball.trail.push({ x: ball.x, y: ball.y, alpha: 1 });
          if (ball.trail.length > 12) ball.trail.shift();

          // Trail particles (fire effect)
          if (Math.random() < 0.4) {
            trailParticles.push({
              x: ball.x + (Math.random() - 0.5) * 8,
              y: ball.y + (Math.random() - 0.5) * 8,
              vx: (Math.random() - 0.5) * 40,
              vy: (Math.random() - 0.5) * 40 - 20,
              life: 0.3 + Math.random() * 0.2,
              maxLife: 0.3 + Math.random() * 0.2,
              size: 2 + Math.random() * 3,
              color: Math.random() > 0.5 ? '#ffaa00' : '#ff6600'
            });
          }

          // Wall bounces
          if (ball.x - ball.r <= 0 && ball.vx < 0) {
            ball.x = ball.r; ball.vx *= -1;
            spawnExplosion(ball.x, ball.y, '#ffcc44', 6);
          }
          if (ball.x + ball.r >= W && ball.vx > 0) {
            ball.x = W - ball.r; ball.vx *= -1;
            spawnExplosion(ball.x, ball.y, '#ffcc44', 6);
          }
          if (ball.y - ball.r <= 0 && ball.vy < 0) {
            ball.y = ball.r; ball.vy *= -1;
            spawnExplosion(ball.x, ball.y, '#ffcc44', 6);
          }

          // Paddle collision
          if (
            ball.x + ball.r >= paddle.x &&
            ball.x - ball.r <= paddle.x + paddle.width &&
            ball.y + ball.r >= paddle.y &&
            ball.y - ball.r <= paddle.y + paddle.height &&
            ball.vy > 0
          ) {
            ball.y = paddle.y - ball.r;
            const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
            const angle = hitPos * (Math.PI / 3.2);
            const speed = Math.max(360, Math.hypot(ball.vx, ball.vy));
            ball.vx = Math.sin(angle) * speed;
            ball.vy = -Math.cos(angle) * speed;
            screenShake = 2;
            spawnExplosion(ball.x, paddle.y, '#88ddff', 8);
          }

          // Brick collision
          for (const brick of bricks) {
            if (!brick.alive) continue;
            if (resolveBallBrickCollision(ball, brick)) break;
          }

          // Ball lost
          if (ball.y - ball.r > H + 40) {
            balls.splice(i, 1);
          }
        }

        if (balls.length === 0 && !won) {
          running = false;
          lost = true;
          statusEl.textContent = "ÈæôÁè†‰∏¢Â§±... Â∑¶ÈîÆÈáçÊñ∞ÂºÄÂßã";
          screenShake = 8;
        }
      }

      // Update brick hit flash
      bricks.forEach(b => { if (b.hitFlash > 0) b.hitFlash--; });

      // Update explosions
      for (let i = explosions.length - 1; i >= 0; i--) {
        const p = explosions[i];
        p.life -= dt;
        if (p.life <= 0) { explosions.splice(i, 1); continue; }
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.98;
        p.vy *= 0.98;
      }

      // Update shockwaves
      for (let i = shockwaves.length - 1; i >= 0; i--) {
        const sw = shockwaves[i];
        sw.life -= dt;
        if (sw.life <= 0) { shockwaves.splice(i, 1); continue; }
        sw.radius = sw.maxRadius * (1 - sw.life / sw.maxLife);
      }

      // Update trail particles
      for (let i = trailParticles.length - 1; i >= 0; i--) {
        const p = trailParticles[i];
        p.life -= dt;
        if (p.life <= 0) { trailParticles.splice(i, 1); continue; }
        p.x += p.vx * dt;
        p.y += p.vy * dt;
      }
    }

    function draw() {
      ctx.save();

      // Screen shake
      if (screenShake > 0) {
        ctx.translate(
          (Math.random() - 0.5) * screenShake * 2,
          (Math.random() - 0.5) * screenShake * 2
        );
      }

      // Background
      const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
      bgGrad.addColorStop(0, '#0a0815');
      bgGrad.addColorStop(0.5, '#0d0a1a');
      bgGrad.addColorStop(1, '#080612');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, W, H);

      // Ambient glow
      const ambientGlow = ctx.createRadialGradient(W * 0.5, H * 0.3, 50, W * 0.5, H * 0.3, H * 0.8);
      ambientGlow.addColorStop(0, 'rgba(255, 150, 0, 0.04)');
      ambientGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = ambientGlow;
      ctx.fillRect(0, 0, W, H);

      // Stars
      bgStars.forEach(s => {
        ctx.fillStyle = `rgba(200, 220, 255, ${s.alpha})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
        ctx.fill();
      });

      // Shockwaves
      shockwaves.forEach(sw => {
        const alpha = sw.life / sw.maxLife;
        ctx.strokeStyle = hexToRgba(sw.color, alpha * 0.6);
        ctx.lineWidth = 3 * alpha;
        ctx.beginPath();
        ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2);
        ctx.stroke();
      });

      // Bricks
      for (const brick of bricks) {
        if (!brick.alive) continue;

        // Brick glow underneath
        ctx.fillStyle = brick.glow;
        ctx.fillRect(brick.x - 2, brick.y - 2, brick.w + 4, brick.h + 4);

        // Main brick body
        const brickGrad = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.h);
        brickGrad.addColorStop(0, brick.highlight);
        brickGrad.addColorStop(0.4, brick.color);
        brickGrad.addColorStop(1, hexToRgba(brick.color, 0.7));
        ctx.fillStyle = brickGrad;
        ctx.beginPath();
        ctx.roundRect(brick.x, brick.y, brick.w, brick.h, 3);
        ctx.fill();

        // Top highlight
        ctx.fillStyle = 'rgba(255,255,255,0.2)';
        ctx.fillRect(brick.x + 2, brick.y + 1, brick.w - 4, 4);

        // Bottom shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(brick.x + 2, brick.y + brick.h - 3, brick.w - 4, 2);

        // HP indicator for tough bricks
        if (brick.maxHp > 1 && brick.hp > 1) {
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.roundRect(brick.x + 2, brick.y + 2, brick.w - 4, brick.h - 4, 2);
          ctx.stroke();
        }

        // Hit flash
        if (brick.hitFlash > 0) {
          ctx.fillStyle = `rgba(255,255,255,${brick.hitFlash / 8 * 0.6})`;
          ctx.beginPath();
          ctx.roundRect(brick.x, brick.y, brick.w, brick.h, 3);
          ctx.fill();
        }
      }

      // Trail particles (fire effect behind ball)
      for (const p of trailParticles) {
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = hexToRgba(p.color, alpha * 0.7);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
      }

      // Balls (Dragon Balls!)
      for (const ball of balls) {
        // Trail glow
        for (let i = 0; i < ball.trail.length; i++) {
          const t = ball.trail[i];
          const alpha = (i + 1) / ball.trail.length;
          const trailGlow = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, ball.r * 1.5);
          trailGlow.addColorStop(0, `rgba(255, 180, 50, ${alpha * 0.15})`);
          trailGlow.addColorStop(1, 'rgba(255, 120, 0, 0)');
          ctx.fillStyle = trailGlow;
          ctx.beginPath();
          ctx.arc(t.x, t.y, ball.r * (0.5 + alpha * 0.6), 0, Math.PI * 2);
          ctx.fill();
        }

        // Ball outer glow
        const ballGlow = ctx.createRadialGradient(ball.x, ball.y, ball.r * 0.5, ball.x, ball.y, ball.r * 2.5);
        ballGlow.addColorStop(0, 'rgba(255, 180, 50, 0.35)');
        ballGlow.addColorStop(0.5, 'rgba(255, 120, 0, 0.1)');
        ballGlow.addColorStop(1, 'rgba(255, 80, 0, 0)');
        ctx.fillStyle = ballGlow;
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r * 2.5, 0, Math.PI * 2);
        ctx.fill();

        // Draw dragon ball image
        if (imgLoaded) {
          ctx.save();
          ctx.translate(ball.x, ball.y);
          ctx.rotate(ball.rotation);
          ctx.drawImage(dragonBallImg, -ball.r, -ball.r, ball.r * 2, ball.r * 2);
          ctx.restore();
        } else {
          // Fallback: orange sphere
          const sphereGrad = ctx.createRadialGradient(
            ball.x - ball.r * 0.3, ball.y - ball.r * 0.3, ball.r * 0.1,
            ball.x, ball.y, ball.r
          );
          sphereGrad.addColorStop(0, '#ffe8a0');
          sphereGrad.addColorStop(0.5, '#ffaa33');
          sphereGrad.addColorStop(1, '#cc6600');
          ctx.fillStyle = sphereGrad;
          ctx.beginPath();
          ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
          ctx.fill();

          // Star
          ctx.fillStyle = '#cc3300';
          ctx.beginPath();
          drawStar(ctx, ball.x, ball.y, 5, ball.r * 0.45, ball.r * 0.22);
          ctx.fill();
        }
      }

      // Explosion particles
      for (const p of explosions) {
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = hexToRgba(p.color, alpha);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * (0.5 + alpha * 0.5), 0, Math.PI * 2);
        ctx.fill();

        // Particle glow
        ctx.fillStyle = hexToRgba(p.color, alpha * 0.3);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * (1 + alpha), 0, Math.PI * 2);
        ctx.fill();
      }

      // Paddle with premium look
      const paddleShadow = ctx.createLinearGradient(paddle.x, paddle.y + paddle.height, paddle.x, paddle.y + paddle.height + 8);
      paddleShadow.addColorStop(0, 'rgba(0,0,0,0.3)');
      paddleShadow.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = paddleShadow;
      ctx.beginPath();
      ctx.roundRect(paddle.x + 4, paddle.y + paddle.height, paddle.width - 8, 8, 4);
      ctx.fill();

      // Paddle glow
      const paddleGlow = ctx.createRadialGradient(
        paddle.x + paddle.width / 2, paddle.y + paddle.height / 2, 10,
        paddle.x + paddle.width / 2, paddle.y + paddle.height / 2, 100
      );
      paddleGlow.addColorStop(0, 'rgba(100, 200, 255, 0.15)');
      paddleGlow.addColorStop(1, 'rgba(100, 200, 255, 0)');
      ctx.fillStyle = paddleGlow;
      ctx.fillRect(paddle.x - 40, paddle.y - 20, paddle.width + 80, paddle.height + 40);

      // Paddle body
      const paddleGrad = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
      paddleGrad.addColorStop(0, '#e0f8ff');
      paddleGrad.addColorStop(0.3, '#88ddff');
      paddleGrad.addColorStop(0.7, '#44aadd');
      paddleGrad.addColorStop(1, '#2288aa');
      ctx.fillStyle = paddleGrad;
      ctx.beginPath();
      ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 8);
      ctx.fill();

      // Paddle shine
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      ctx.beginPath();
      ctx.roundRect(paddle.x + 8, paddle.y + 2, paddle.width - 16, 5, 3);
      ctx.fill();

      // Paddle edge lights
      ctx.fillStyle = 'rgba(150, 220, 255, 0.6)';
      ctx.beginPath();
      ctx.arc(paddle.x + 6, paddle.y + paddle.height / 2, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(paddle.x + paddle.width - 6, paddle.y + paddle.height / 2, 3, 0, Math.PI * 2);
      ctx.fill();

      // Preview ball when not launched
      if (!running && !won && !lost) {
        const previewX = paddle.x + paddle.width / 2;
        const previewY = paddle.y - 16;
        const pulseR = 12 + Math.sin(performance.now() * 0.005) * 2;

        // Preview glow
        const preGlow = ctx.createRadialGradient(previewX, previewY, 2, previewX, previewY, pulseR * 2);
        preGlow.addColorStop(0, 'rgba(255, 180, 50, 0.3)');
        preGlow.addColorStop(1, 'rgba(255, 100, 0, 0)');
        ctx.fillStyle = preGlow;
        ctx.beginPath();
        ctx.arc(previewX, previewY, pulseR * 2, 0, Math.PI * 2);
        ctx.fill();

        if (imgLoaded) {
          ctx.save();
          ctx.translate(previewX, previewY);
          ctx.rotate(performance.now() * 0.002);
          ctx.drawImage(dragonBallImg, -pulseR, -pulseR, pulseR * 2, pulseR * 2);
          ctx.restore();
        } else {
          ctx.fillStyle = '#ffaa33';
          ctx.beginPath();
          ctx.arc(previewX, previewY, pulseR, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      // Win/Lose overlay
      if (won || lost) {
        ctx.fillStyle = 'rgba(3, 5, 15, 0.65)';
        ctx.fillRect(0, 0, W, H);

        ctx.textAlign = 'center';

        if (won) {
          // Victory glow
          const victoryGlow = ctx.createRadialGradient(W / 2, H / 2, 20, W / 2, H / 2, 200);
          victoryGlow.addColorStop(0, 'rgba(255, 200, 50, 0.15)');
          victoryGlow.addColorStop(1, 'rgba(255, 150, 0, 0)');
          ctx.fillStyle = victoryGlow;
          ctx.fillRect(0, 0, W, H);

          ctx.font = 'bold 56px Orbitron';
          ctx.fillStyle = '#ffcc33';
          ctx.shadowColor = 'rgba(255, 180, 50, 0.6)';
          ctx.shadowBlur = 20;
          ctx.fillText('üêâ VICTORY!', W / 2, H / 2 - 20);
        } else {
          ctx.font = 'bold 56px Orbitron';
          ctx.fillStyle = '#ff4444';
          ctx.shadowColor = 'rgba(255, 50, 50, 0.6)';
          ctx.shadowBlur = 20;
          ctx.fillText('GAME OVER', W / 2, H / 2 - 20);
        }

        ctx.shadowBlur = 0;
        ctx.font = '18px Orbitron';
        ctx.fillStyle = 'rgba(255, 200, 150, 0.8)';
        ctx.fillText(`SCORE: ${score}`, W / 2, H / 2 + 20);
        ctx.font = '14px Orbitron';
        ctx.fillStyle = 'rgba(200, 200, 255, 0.6)';
        ctx.fillText('Â∑¶ÈîÆÁÇπÂáªÈáçÊñ∞ÂºÄÂßã', W / 2, H / 2 + 50);
      }

      // Vignette
      const vignette = ctx.createRadialGradient(W / 2, H / 2, W * 0.25, W / 2, H / 2, W * 0.7);
      vignette.addColorStop(0, 'rgba(0,0,0,0)');
      vignette.addColorStop(1, 'rgba(0,0,0,0.35)');
      ctx.fillStyle = vignette;
      ctx.fillRect(0, 0, W, H);

      ctx.restore();
    }

    function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
      let rot = Math.PI / 2 * 3;
      const step = Math.PI / spikes;
      ctx.moveTo(cx, cy - outerRadius);
      for (let i = 0; i < spikes; i++) {
        ctx.lineTo(cx + Math.cos(rot) * outerRadius, cy + Math.sin(rot) * outerRadius);
        rot += step;
        ctx.lineTo(cx + Math.cos(rot) * innerRadius, cy + Math.sin(rot) * innerRadius);
        rot += step;
      }
      ctx.lineTo(cx, cy - outerRadius);
    }

    function hexToRgba(hex, alpha) {
      const safeHex = hex.replace('#', '').trim();
      const expanded = safeHex.length === 3
        ? safeHex.split('').map(c => c + c).join('')
        : safeHex;
      const num = Number.parseInt(expanded, 16);
      const r = (num >> 16) & 255;
      const g = (num >> 8) & 255;
      const b = num & 255;
      return `rgba(${r}, ${g}, ${b}, ${Math.max(0, Math.min(1, alpha))})`;
    }

    function gameLoop(now) {
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener('mousemove', (event) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      mouseX = (event.clientX - rect.left) * scaleX;
    });

    canvas.addEventListener('mousedown', (event) => {
      if (event.button !== 0) return;
      if (won || lost) { restartAfterEnd(); return; }
      launchBall();
    });

    canvas.addEventListener('contextmenu', (event) => event.preventDefault());

    resetLevel();
    requestAnimationFrame((t) => {
      lastTime = t;
      gameLoop(t);
    });
  </script>
</body>

</html>