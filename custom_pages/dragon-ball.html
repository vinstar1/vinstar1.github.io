<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>‰∏ÉÈæôÁè†ÂºπÁêÉ - Dragon Ball Breakout</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #050510;
      font-family: 'Orbitron', sans-serif;
      color: #e8f3ff;
      user-select: none;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: block;
      cursor: crosshair;
    }

    #hud {
      position: fixed;
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 28px;
      align-items: center;
      padding: 8px 24px;
      border-radius: 10px;
      background: rgba(10, 12, 25, 0.75);
      border: 1px solid rgba(255, 180, 50, 0.15);
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 24px rgba(0, 0, 0, 0.5);
      z-index: 20;
      font-size: 11px;
      letter-spacing: 1.2px;
      text-transform: uppercase;
    }

    .hud-item .label {
      color: rgba(255, 200, 100, 0.5);
      font-size: 9px;
    }

    .hud-item .value {
      color: #ffcc33;
      font-weight: 700;
      font-size: 13px;
      text-shadow: 0 0 8px rgba(255, 180, 50, 0.4);
    }

    #status {
      color: rgba(255, 200, 120, 0.6);
      font-size: 10px;
    }

    .back-btn {
      position: fixed;
      top: 12px;
      right: 16px;
      z-index: 30;
      background: rgba(10, 15, 30, 0.7);
      border: 1px solid rgba(255, 180, 50, 0.2);
      color: rgba(255, 200, 120, 0.7);
      padding: 6px 14px;
      border-radius: 6px;
      font-family: 'Orbitron', sans-serif;
      font-size: 10px;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.3s;
      letter-spacing: 1px;
    }

    .back-btn:hover {
      background: rgba(60, 40, 10, 0.5);
      border-color: rgba(255, 180, 50, 0.4);
      color: #ffcc33;
    }
  </style>
</head>

<body>
  <a class="back-btn" href="/custom_pages/games.html">‚óÄ BACK</a>

  <div id="hud">
    <div class="hud-item"><span class="label">SCORE </span><span class="value" id="score">0</span></div>
    <div class="hud-item"><span class="label">BRICKS </span><span class="value" id="remain">0</span></div>
    <div class="hud-item"><span class="label">COMBO </span><span class="value" id="combo">x1</span></div>
    <div class="hud-item"><span class="label">BALLS </span><span class="value" id="ballcount">1</span></div>
    <div id="status">ÁßªÂä®Èº†Ê†áÊéßÂà∂Êå°Êùø ¬∑ Â∑¶ÈîÆÂèëÂ∞ÑÈæôÁè†</div>
  </div>

  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const remainEl = document.getElementById("remain");
    const scoreEl = document.getElementById("score");
    const comboEl = document.getElementById("combo");
    const ballCountEl = document.getElementById("ballcount");

    // ==============================
    // ‚ñº‚ñº‚ñº ÂàÜË£ÇÁêÉÈÖçÁΩÆÂå∫ (SPLIT BALL CONFIG) ‚ñº‚ñº‚ñº
    // ==============================
    //
    // splitOnHit: true ‚Üí ËØ•Á†ñÂùóË¢´Âáª‰∏≠ÂêéÔºåÈæôÁè†‰ºöÂàÜË£ÇÊàêÂ§öÈ¢ó
    // splitCount: ÂàÜË£Ç‰∫ßÁîüÁöÑÈ¢ùÂ§ñÁêÉÊï∞Èáè (1 = ÂàÜË£ÇÂá∫1‰∏™, 2 = ÂàÜË£ÇÂá∫2‰∏™)
    // splitAngleOffset: ÂàÜË£ÇËßíÂ∫¶ÂÅèÁßª (ÂºßÂ∫¶ÔºåË∂äÂ§ßÂàÜË£ÇË∂äÊâ©Êï£ÔºåÂª∫ËÆÆ 0.3 ~ 0.8)
    //
    // ‰Ω†ÂèØ‰ª•Âú® resetLevel() ÂáΩÊï∞‰∏≠ËÆæÁΩÆÂì™‰∫õÁ†ñÂùóÊúâÂàÜË£ÇÂ±ûÊÄßÔºö
    //   - ÊåâË°å: row === 0 ‚Üí Á¨¨‰∏ÄË°åÊâÄÊúâÁ†ñÂùó
    //   - ÊåâÂàó: col === 5 ‚Üí Á¨¨6Âàó
    //   - ÊåâÊù°‰ª∂: row % 3 === 0 ‚Üí ÊØè3Ë°å‰∏ÄÊ¨°
    //   - ÁâπÂÆö‰ΩçÁΩÆ: row === 2 && col === 3 ‚Üí ÂÖ∑‰ΩìÊüê‰∏ÄÂùó
    //
    // Á§∫‰æã:
    //   splitOnHit: row === 0,           ‚Üê Á¨¨‰∏ÄË°åÁöÑÁ†ñÂùóÊúâÂàÜË£ÇÊïàÊûú
    //   splitOnHit: col === 0 || col === levelConfig.cols - 1,  ‚Üê ‰∏§‰æßÁ†ñÂùó
    //   splitOnHit: (row + col) % 4 === 0,   ‚Üê Èó¥ÈöîÂàÜÂ∏ÉÂàÜË£ÇÁ†ñÂùó
    //
    // ==============================
    // ‚ñ≤‚ñ≤‚ñ≤ ÂàÜË£ÇÁêÉÈÖçÁΩÆÂå∫ ‚ñ≤‚ñ≤‚ñ≤
    // ==============================

    const SPLIT_CONFIG = {
      splitCount: 2,           // ÊØèÊ¨°ÂàÜË£Ç‰∫ßÁîüÂá†È¢óÊñ∞ÁêÉ
      angleOffset: 0.5,        // ÂàÜË£ÇËßíÂ∫¶ (ÂºßÂ∫¶)
      maxBalls: 16             // Âú∫‰∏äÊúÄÂ§öÂêåÊó∂Â≠òÂú®Âá†È¢óÁêÉ
    };

    // === Full-screen rendering ===
    // Logical game resolution
    const LOGICAL_W = 960;
    const LOGICAL_H = 540;
    let displayScale = 1;
    let displayOffsetX = 0;
    let displayOffsetY = 0;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // Scale to fill screen while keeping 16:9 aspect
      const scaleX = canvas.width / LOGICAL_W;
      const scaleY = canvas.height / LOGICAL_H;
      displayScale = Math.max(scaleX, scaleY); // fill (cover) instead of fit (contain)
      displayOffsetX = (canvas.width - LOGICAL_W * displayScale) / 2;
      displayOffsetY = (canvas.height - LOGICAL_H * displayScale) / 2;
    }
    window.addEventListener('resize', resize);
    resize();

    // Dragon Ball sprite
    const dragonBallImg = new Image();
    dragonBallImg.src = "dragon-ball-sphere.png";
    let imgLoaded = false;
    dragonBallImg.onload = () => { imgLoaded = true; };

    const paddle = {
      width: 160, height: 16,
      x: LOGICAL_W / 2 - 80, y: LOGICAL_H - 48,
      targetX: LOGICAL_W / 2 - 80,
      speedFollow: 0.18
    };

    const levelConfig = {
      rows: 7, cols: 12,
      brickW: 68, brickH: 22,
      gap: 6, offsetTop: 48
    };

    const balls = [];
    const bricks = [];
    const explosions = [];
    const shockwaves = [];
    const trailParticles = [];

    let running = false;
    let won = false;
    let lost = false;
    let mouseX = LOGICAL_W / 2;
    let lastTime = performance.now();
    let score = 0;
    let combo = 0;
    let comboTimer = 0;
    let screenShake = 0;

    const bgStars = [];
    for (let i = 0; i < 120; i++) {
      bgStars.push({
        x: Math.random(), y: Math.random(),
        size: Math.random() * 1.5 + 0.3,
        alpha: Math.random() * 0.5 + 0.1,
        twinkleSpeed: Math.random() * 0.03 + 0.01
      });
    }

    const BRICK_COLORS = [
      { fill: '#ff4444', glow: 'rgba(255,68,68,0.4)', highlight: '#ff8888' },
      { fill: '#ff8800', glow: 'rgba(255,136,0,0.4)', highlight: '#ffbb44' },
      { fill: '#ffcc00', glow: 'rgba(255,204,0,0.4)', highlight: '#ffee66' },
      { fill: '#44cc44', glow: 'rgba(68,204,68,0.4)', highlight: '#88ee88' },
      { fill: '#4488ff', glow: 'rgba(68,136,255,0.4)', highlight: '#88bbff' },
      { fill: '#cc44ff', glow: 'rgba(204,68,255,0.4)', highlight: '#dd88ff' },
      { fill: '#ff4488', glow: 'rgba(255,68,136,0.4)', highlight: '#ff88bb' },
    ];

    function createBall(x, y, vx, vy) {
      if (balls.length >= SPLIT_CONFIG.maxBalls) return;
      balls.push({
        x, y, vx, vy,
        r: 12,
        trail: [],
        rotation: 0,
        rotSpeed: (Math.random() - 0.5) * 10
      });
      ballCountEl.textContent = balls.length;
    }

    function resetLevel() {
      balls.length = 0;
      bricks.length = 0;
      explosions.length = 0;
      shockwaves.length = 0;
      trailParticles.length = 0;
      running = false; won = false; lost = false;
      score = 0; combo = 0; comboTimer = 0;
      scoreEl.textContent = '0';
      comboEl.textContent = 'x1';
      ballCountEl.textContent = '0';

      const totalW = levelConfig.cols * levelConfig.brickW + (levelConfig.cols - 1) * levelConfig.gap;
      const startX = (LOGICAL_W - totalW) / 2;

      for (let row = 0; row < levelConfig.rows; row++) {
        for (let col = 0; col < levelConfig.cols; col++) {
          const colorSet = BRICK_COLORS[row % BRICK_COLORS.length];
          bricks.push({
            x: startX + col * (levelConfig.brickW + levelConfig.gap),
            y: levelConfig.offsetTop + row * (levelConfig.brickH + levelConfig.gap),
            w: levelConfig.brickW,
            h: levelConfig.brickH,
            alive: true,
            color: colorSet.fill,
            glow: colorSet.glow,
            highlight: colorSet.highlight,
            hp: row === 0 ? 2 : 1,
            maxHp: row === 0 ? 2 : 1,
            hitFlash: 0,
            // ‚òÖ‚òÖ‚òÖ ÂàÜË£ÇÁêÉËÆæÁΩÆ ‚òÖ‚òÖ‚òÖ
            // ‰øÆÊîπ‰∏ãÈù¢ËøôË°åÊù•ÊéßÂà∂Âì™‰∫õÁ†ñÂùóËß¶ÂèëÂàÜË£ÇÔºö
            splitOnHit: row === 0 && (col === 0 || col === levelConfig.cols - 1)
            // ÂΩìÂâçËÆæÁΩÆ: Á¨¨‰∏ÄË°å‰∏§Á´ØÁöÑÁ†ñÂùó
            // ÂÖ∂‰ªñÁ§∫‰æã:
            //   splitOnHit: row === 0                    ‚Üê Á¨¨‰∏ÄË°åÂÖ®ÈÉ®
            //   splitOnHit: (row + col) % 5 === 0        ‚Üê ÂùáÂåÄÂàÜÂ∏É
            //   splitOnHit: col === Math.floor(levelConfig.cols / 2)  ‚Üê ‰∏≠Èó¥Âàó
          });
        }
      }

      statusEl.textContent = "ÁßªÂä®Èº†Ê†áÊéßÂà∂Êå°Êùø ¬∑ Â∑¶ÈîÆÂèëÂ∞ÑÈæôÁè†";
      updateRemainText();
    }

    function updateRemainText() {
      remainEl.textContent = bricks.filter(b => b.alive).length;
    }

    function launchBall() {
      if (running || won || lost) return;
      createBall(
        paddle.x + paddle.width / 2,
        paddle.y - 14,
        (Math.random() * 2 - 1) * 140,
        -380
      );
      running = true;
      statusEl.textContent = "ÈæôÁè†Â∑≤ÂèëÂ∞ÑÔºÅ";
    }

    function restartAfterEnd() {
      if (!won && !lost) return;
      resetLevel();
    }

    function spawnExplosion(x, y, color, count = 22) {
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count + Math.random() * 0.4;
        const speed = 80 + Math.random() * 220;
        explosions.push({
          x, y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0.5 + Math.random() * 0.3,
          maxLife: 0.5 + Math.random() * 0.3,
          size: 2.5 + Math.random() * 4,
          color
        });
      }
    }

    function spawnShockwave(x, y, color) {
      shockwaves.push({ x, y, radius: 0, maxRadius: 70, life: 0.4, maxLife: 0.4, color });
    }

    function resolveBallBrickCollision(ball, brick) {
      const nearestX = Math.max(brick.x, Math.min(ball.x, brick.x + brick.w));
      const nearestY = Math.max(brick.y, Math.min(ball.y, brick.y + brick.h));
      const dx = ball.x - nearestX;
      const dy = ball.y - nearestY;

      if (dx * dx + dy * dy > ball.r * ball.r) return false;

      const overlapLeft = ball.x + ball.r - brick.x;
      const overlapRight = brick.x + brick.w - (ball.x - ball.r);
      const overlapTop = ball.y + ball.r - brick.y;
      const overlapBottom = brick.y + brick.h - (ball.y - ball.r);
      const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

      if (minOverlap === overlapLeft || minOverlap === overlapRight) ball.vx *= -1;
      else ball.vy *= -1;

      brick.hp--;
      brick.hitFlash = 8;
      screenShake = 4;

      if (brick.hp <= 0) {
        brick.alive = false;
        const cx = brick.x + brick.w / 2;
        const cy = brick.y + brick.h / 2;
        spawnExplosion(cx, cy, brick.color, 18);
        spawnShockwave(cx, cy, brick.color);

        // ‚òÖ ÂàÜË£ÇÁêÉÈÄªËæë ‚òÖ
        if (brick.splitOnHit && balls.length < SPLIT_CONFIG.maxBalls) {
          const speed = Math.hypot(ball.vx, ball.vy);
          const baseAngle = Math.atan2(ball.vy, ball.vx);
          for (let s = 0; s < SPLIT_CONFIG.splitCount; s++) {
            const offset = SPLIT_CONFIG.angleOffset * (s + 1) * (s % 2 === 0 ? 1 : -1);
            const newAngle = baseAngle + offset;
            createBall(ball.x, ball.y, Math.cos(newAngle) * speed, Math.sin(newAngle) * speed);
          }
          // ÂàÜË£ÇÁâπÊïà
          spawnExplosion(ball.x, ball.y, '#ffaa00', 12);
          spawnShockwave(ball.x, ball.y, '#ffcc00');
          screenShake = 8;
          statusEl.textContent = `üêâ ÈæôÁè†ÂàÜË£ÇÔºÅÂΩìÂâç ${balls.length} È¢ó`;
        }

        comboTimer = 60; combo++;
        score += 100 * combo;
        scoreEl.textContent = score;
        comboEl.textContent = `x${combo}`;

        updateRemainText();
        if (bricks.every(b => !b.alive)) {
          running = false; won = true;
          statusEl.textContent = "üêâ ËÉúÂà©ÔºÅÈõÜÈΩêÈæôÁè†ÔºÅÂ∑¶ÈîÆÈáçÊñ∞ÂºÄÂßã";
          screenShake = 12;
        }
      }
      return true;
    }

    function update(dt) {
      paddle.targetX = mouseX - paddle.width / 2;
      paddle.x += (paddle.targetX - paddle.x) * paddle.speedFollow;
      paddle.x = Math.max(0, Math.min(LOGICAL_W - paddle.width, paddle.x));

      if (comboTimer > 0) { comboTimer--; if (comboTimer === 0) { combo = 0; comboEl.textContent = 'x1'; } }
      if (screenShake > 0) screenShake *= 0.85;
      if (screenShake < 0.1) screenShake = 0;

      if (running) {
        for (let i = balls.length - 1; i >= 0; i--) {
          const ball = balls[i];
          ball.x += ball.vx * dt;
          ball.y += ball.vy * dt;
          ball.rotation += ball.rotSpeed * dt;

          ball.trail.push({ x: ball.x, y: ball.y });
          if (ball.trail.length > 12) ball.trail.shift();

          if (Math.random() < 0.4) {
            trailParticles.push({
              x: ball.x + (Math.random() - 0.5) * 8, y: ball.y + (Math.random() - 0.5) * 8,
              vx: (Math.random() - 0.5) * 40, vy: (Math.random() - 0.5) * 40 - 20,
              life: 0.3 + Math.random() * 0.2, maxLife: 0.3 + Math.random() * 0.2,
              size: 2 + Math.random() * 3, color: Math.random() > 0.5 ? '#ffaa00' : '#ff6600'
            });
          }

          if (ball.x - ball.r <= 0 && ball.vx < 0) { ball.x = ball.r; ball.vx *= -1; spawnExplosion(ball.x, ball.y, '#ffcc44', 6); }
          if (ball.x + ball.r >= LOGICAL_W && ball.vx > 0) { ball.x = LOGICAL_W - ball.r; ball.vx *= -1; spawnExplosion(ball.x, ball.y, '#ffcc44', 6); }
          if (ball.y - ball.r <= 0 && ball.vy < 0) { ball.y = ball.r; ball.vy *= -1; spawnExplosion(ball.x, ball.y, '#ffcc44', 6); }

          if (ball.x + ball.r >= paddle.x && ball.x - ball.r <= paddle.x + paddle.width &&
            ball.y + ball.r >= paddle.y && ball.y - ball.r <= paddle.y + paddle.height && ball.vy > 0) {
            ball.y = paddle.y - ball.r;
            const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
            const angle = hitPos * (Math.PI / 3.2);
            const speed = Math.max(360, Math.hypot(ball.vx, ball.vy));
            ball.vx = Math.sin(angle) * speed; ball.vy = -Math.cos(angle) * speed;
            screenShake = 2; spawnExplosion(ball.x, paddle.y, '#88ddff', 8);
          }

          for (const brick of bricks) {
            if (!brick.alive) continue;
            if (resolveBallBrickCollision(ball, brick)) break;
          }

          if (ball.y - ball.r > LOGICAL_H + 40) { balls.splice(i, 1); }
        }

        ballCountEl.textContent = balls.length;

        if (balls.length === 0 && !won) {
          running = false; lost = true;
          statusEl.textContent = "ÈæôÁè†‰∏¢Â§±... Â∑¶ÈîÆÈáçÊñ∞ÂºÄÂßã";
          screenShake = 8;
        }
      }

      bricks.forEach(b => { if (b.hitFlash > 0) b.hitFlash--; });

      for (let i = explosions.length - 1; i >= 0; i--) {
        const p = explosions[i]; p.life -= dt;
        if (p.life <= 0) { explosions.splice(i, 1); continue; }
        p.x += p.vx * dt; p.y += p.vy * dt; p.vx *= 0.98; p.vy *= 0.98;
      }
      for (let i = shockwaves.length - 1; i >= 0; i--) {
        const sw = shockwaves[i]; sw.life -= dt;
        if (sw.life <= 0) { shockwaves.splice(i, 1); continue; }
        sw.radius = sw.maxRadius * (1 - sw.life / sw.maxLife);
      }
      for (let i = trailParticles.length - 1; i >= 0; i--) {
        const p = trailParticles[i]; p.life -= dt;
        if (p.life <= 0) { trailParticles.splice(i, 1); continue; }
        p.x += p.vx * dt; p.y += p.vy * dt;
      }
    }

    function draw() {
      // Full-screen background
      ctx.fillStyle = '#050510';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars across entire screen
      bgStars.forEach(s => {
        s.alpha = 0.1 + Math.abs(Math.sin(performance.now() * s.twinkleSpeed)) * 0.4;
        ctx.fillStyle = `rgba(200,220,255,${s.alpha})`;
        ctx.beginPath(); ctx.arc(s.x * canvas.width, s.y * canvas.height, s.size, 0, Math.PI * 2); ctx.fill();
      });

      // Transform to game space
      ctx.save();
      ctx.translate(displayOffsetX, displayOffsetY);
      ctx.scale(displayScale, displayScale);

      if (screenShake > 0) {
        ctx.translate((Math.random() - 0.5) * screenShake * 2, (Math.random() - 0.5) * screenShake * 2);
      }

      // Game area bg
      const bgGrad = ctx.createLinearGradient(0, 0, 0, LOGICAL_H);
      bgGrad.addColorStop(0, '#0a0815'); bgGrad.addColorStop(0.5, '#0d0a1a'); bgGrad.addColorStop(1, '#080612');
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);

      // Ambient glow
      const ag = ctx.createRadialGradient(LOGICAL_W * 0.5, LOGICAL_H * 0.3, 50, LOGICAL_W * 0.5, LOGICAL_H * 0.3, LOGICAL_H * 0.8);
      ag.addColorStop(0, 'rgba(255,150,0,0.04)'); ag.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = ag; ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);

      // Shockwaves
      shockwaves.forEach(sw => {
        const a = sw.life / sw.maxLife;
        ctx.strokeStyle = hexToRgba(sw.color, a * 0.6); ctx.lineWidth = 3 * a;
        ctx.beginPath(); ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2); ctx.stroke();
      });

      // Bricks
      for (const brick of bricks) {
        if (!brick.alive) continue;
        ctx.fillStyle = brick.glow; ctx.fillRect(brick.x - 2, brick.y - 2, brick.w + 4, brick.h + 4);
        const bg = ctx.createLinearGradient(brick.x, brick.y, brick.x, brick.y + brick.h);
        bg.addColorStop(0, brick.highlight); bg.addColorStop(0.4, brick.color); bg.addColorStop(1, hexToRgba(brick.color, 0.7));
        ctx.fillStyle = bg;
        ctx.beginPath(); ctx.roundRect(brick.x, brick.y, brick.w, brick.h, 3); ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fillRect(brick.x + 2, brick.y + 1, brick.w - 4, 4);
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(brick.x + 2, brick.y + brick.h - 3, brick.w - 4, 2);

        // HP indicator
        if (brick.maxHp > 1 && brick.hp > 1) {
          ctx.strokeStyle = 'rgba(255,255,255,0.5)'; ctx.lineWidth = 1.5;
          ctx.beginPath(); ctx.roundRect(brick.x + 2, brick.y + 2, brick.w - 4, brick.h - 4, 2); ctx.stroke();
        }

        // Split indicator ‚òÖ
        if (brick.splitOnHit) {
          ctx.strokeStyle = 'rgba(255,200,0,0.7)'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.roundRect(brick.x + 1, brick.y + 1, brick.w - 2, brick.h - 2, 3); ctx.stroke();
          // Dragon Ball star marker
          ctx.fillStyle = 'rgba(255,200,0,0.8)';
          ctx.font = 'bold 12px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
          ctx.fillText('‚òÖ', brick.x + brick.w / 2, brick.y + brick.h / 2);
        }

        if (brick.hitFlash > 0) {
          ctx.fillStyle = `rgba(255,255,255,${brick.hitFlash / 8 * 0.6})`;
          ctx.beginPath(); ctx.roundRect(brick.x, brick.y, brick.w, brick.h, 3); ctx.fill();
        }
      }

      // Trail particles
      for (const p of trailParticles) {
        const a = p.life / p.maxLife;
        ctx.fillStyle = hexToRgba(p.color, a * 0.7);
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size * a, 0, Math.PI * 2); ctx.fill();
      }

      // Balls
      for (const ball of balls) {
        for (let i = 0; i < ball.trail.length; i++) {
          const t = ball.trail[i]; const a = (i + 1) / ball.trail.length;
          const tg = ctx.createRadialGradient(t.x, t.y, 0, t.x, t.y, ball.r * 1.5);
          tg.addColorStop(0, `rgba(255,180,50,${a * 0.15})`); tg.addColorStop(1, 'rgba(255,120,0,0)');
          ctx.fillStyle = tg; ctx.beginPath(); ctx.arc(t.x, t.y, ball.r * (0.5 + a * 0.6), 0, Math.PI * 2); ctx.fill();
        }
        const bg2 = ctx.createRadialGradient(ball.x, ball.y, ball.r * 0.5, ball.x, ball.y, ball.r * 2.5);
        bg2.addColorStop(0, 'rgba(255,180,50,0.35)'); bg2.addColorStop(0.5, 'rgba(255,120,0,0.1)'); bg2.addColorStop(1, 'rgba(255,80,0,0)');
        ctx.fillStyle = bg2; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r * 2.5, 0, Math.PI * 2); ctx.fill();

        if (imgLoaded) {
          ctx.save(); ctx.translate(ball.x, ball.y); ctx.rotate(ball.rotation);
          ctx.drawImage(dragonBallImg, -ball.r, -ball.r, ball.r * 2, ball.r * 2); ctx.restore();
        } else {
          const sg = ctx.createRadialGradient(ball.x - ball.r * 0.3, ball.y - ball.r * 0.3, ball.r * 0.1, ball.x, ball.y, ball.r);
          sg.addColorStop(0, '#ffe8a0'); sg.addColorStop(0.5, '#ffaa33'); sg.addColorStop(1, '#cc6600');
          ctx.fillStyle = sg; ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2); ctx.fill();
        }
      }

      // Explosion particles
      for (const p of explosions) {
        const a = p.life / p.maxLife;
        ctx.fillStyle = hexToRgba(p.color, a);
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size * (0.5 + a * 0.5), 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = hexToRgba(p.color, a * 0.3);
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size * (1 + a), 0, Math.PI * 2); ctx.fill();
      }

      // Paddle shadow
      const ps = ctx.createLinearGradient(paddle.x, paddle.y + paddle.height, paddle.x, paddle.y + paddle.height + 8);
      ps.addColorStop(0, 'rgba(0,0,0,0.3)'); ps.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = ps; ctx.beginPath(); ctx.roundRect(paddle.x + 4, paddle.y + paddle.height, paddle.width - 8, 8, 4); ctx.fill();

      // Paddle glow
      const pg = ctx.createRadialGradient(paddle.x + paddle.width / 2, paddle.y + paddle.height / 2, 10, paddle.x + paddle.width / 2, paddle.y + paddle.height / 2, 100);
      pg.addColorStop(0, 'rgba(100,200,255,0.15)'); pg.addColorStop(1, 'rgba(100,200,255,0)');
      ctx.fillStyle = pg; ctx.fillRect(paddle.x - 40, paddle.y - 20, paddle.width + 80, paddle.height + 40);

      // Paddle body
      const pbg = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
      pbg.addColorStop(0, '#e0f8ff'); pbg.addColorStop(0.3, '#88ddff'); pbg.addColorStop(0.7, '#44aadd'); pbg.addColorStop(1, '#2288aa');
      ctx.fillStyle = pbg; ctx.beginPath(); ctx.roundRect(paddle.x, paddle.y, paddle.width, paddle.height, 8); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.roundRect(paddle.x + 8, paddle.y + 2, paddle.width - 16, 5, 3); ctx.fill();
      ctx.fillStyle = 'rgba(150,220,255,0.6)';
      ctx.beginPath(); ctx.arc(paddle.x + 6, paddle.y + paddle.height / 2, 3, 0, Math.PI * 2); ctx.fill();
      ctx.beginPath(); ctx.arc(paddle.x + paddle.width - 6, paddle.y + paddle.height / 2, 3, 0, Math.PI * 2); ctx.fill();

      // Preview ball
      if (!running && !won && !lost) {
        const px = paddle.x + paddle.width / 2, py = paddle.y - 16;
        const pr = 12 + Math.sin(performance.now() * 0.005) * 2;
        const prg = ctx.createRadialGradient(px, py, 2, px, py, pr * 2);
        prg.addColorStop(0, 'rgba(255,180,50,0.3)'); prg.addColorStop(1, 'rgba(255,100,0,0)');
        ctx.fillStyle = prg; ctx.beginPath(); ctx.arc(px, py, pr * 2, 0, Math.PI * 2); ctx.fill();
        if (imgLoaded) {
          ctx.save(); ctx.translate(px, py); ctx.rotate(performance.now() * 0.002);
          ctx.drawImage(dragonBallImg, -pr, -pr, pr * 2, pr * 2); ctx.restore();
        } else {
          ctx.fillStyle = '#ffaa33'; ctx.beginPath(); ctx.arc(px, py, pr, 0, Math.PI * 2); ctx.fill();
        }
      }

      // Win/Lose
      if (won || lost) {
        ctx.fillStyle = 'rgba(3,5,15,0.65)'; ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);
        ctx.textAlign = 'center';
        if (won) {
          const vg = ctx.createRadialGradient(LOGICAL_W / 2, LOGICAL_H / 2, 20, LOGICAL_W / 2, LOGICAL_H / 2, 200);
          vg.addColorStop(0, 'rgba(255,200,50,0.15)'); vg.addColorStop(1, 'rgba(255,150,0,0)');
          ctx.fillStyle = vg; ctx.fillRect(0, 0, LOGICAL_W, LOGICAL_H);
          ctx.font = 'bold 56px Orbitron'; ctx.fillStyle = '#ffcc33';
          ctx.shadowColor = 'rgba(255,180,50,0.6)'; ctx.shadowBlur = 20;
          ctx.fillText('üêâ VICTORY!', LOGICAL_W / 2, LOGICAL_H / 2 - 20);
        } else {
          ctx.font = 'bold 56px Orbitron'; ctx.fillStyle = '#ff4444';
          ctx.shadowColor = 'rgba(255,50,50,0.6)'; ctx.shadowBlur = 20;
          ctx.fillText('GAME OVER', LOGICAL_W / 2, LOGICAL_H / 2 - 20);
        }
        ctx.shadowBlur = 0;
        ctx.font = '18px Orbitron'; ctx.fillStyle = 'rgba(255,200,150,0.8)';
        ctx.fillText(`SCORE: ${score}`, LOGICAL_W / 2, LOGICAL_H / 2 + 20);
        ctx.font = '14px Orbitron'; ctx.fillStyle = 'rgba(200,200,255,0.6)';
        ctx.fillText('Â∑¶ÈîÆÁÇπÂáªÈáçÊñ∞ÂºÄÂßã', LOGICAL_W / 2, LOGICAL_H / 2 + 50);
      }

      ctx.restore();

      // Full-screen vignette
      const vig = ctx.createRadialGradient(canvas.width / 2, canvas.height / 2, canvas.width * 0.2, canvas.width / 2, canvas.height / 2, canvas.width * 0.7);
      vig.addColorStop(0, 'rgba(0,0,0,0)'); vig.addColorStop(1, 'rgba(0,0,0,0.4)');
      ctx.fillStyle = vig; ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function hexToRgba(hex, alpha) {
      const s = hex.replace('#', '').trim();
      const e = s.length === 3 ? s.split('').map(c => c + c).join('') : s;
      const n = Number.parseInt(e, 16);
      return `rgba(${(n >> 16) & 255},${(n >> 8) & 255},${n & 255},${Math.max(0, Math.min(1, alpha))})`;
    }

    function gameLoop(now) {
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener('mousemove', (e) => {
      // Convert screen coordinates to logical game coordinates
      const sx = e.clientX;
      const sy = e.clientY;
      mouseX = (sx - displayOffsetX) / displayScale;
    });

    canvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      if (won || lost) { restartAfterEnd(); return; }
      launchBall();
    });

    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    resetLevel();
    requestAnimationFrame((t) => { lastTime = t; gameLoop(t); });
  </script>
</body>

</html>