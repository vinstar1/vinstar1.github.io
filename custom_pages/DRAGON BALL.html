<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>弹球打砖块 - 第一关</title>
  <style>
    :root {
      --bg-top: #0a1629;
      --bg-bottom: #11233f;
      --panel: #1a3159;
      --text: #e8f3ff;
      --accent: #ffb347;
      --brick-a: #ff6b6b;
      --brick-b: #ffd166;
      --brick-c: #06d6a0;
      --brick-d: #4dabf7;
      --paddle: #7bdff2;
      --ball: #ffffff;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      display: grid;
      place-items: center;
      background: radial-gradient(circle at 20% 10%, #1f3c6d 0%, var(--bg-top) 45%, var(--bg-bottom) 100%);
      font-family: "Trebuchet MS", "Segoe UI", sans-serif;
      color: var(--text);
      user-select: none;
    }

    .wrap {
      width: min(94vw, 980px);
      display: grid;
      gap: 12px;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 14px;
      border-radius: 12px;
      background: color-mix(in oklab, var(--panel) 82%, #000 18%);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.25);
      letter-spacing: 0.3px;
      font-size: 14px;
    }

    canvas {
      width: 100%;
      aspect-ratio: 16 / 9;
      display: block;
      background: linear-gradient(180deg, #0d223f 0%, #0a1a30 100%);
      border: 2px solid rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      box-shadow: 0 16px 36px rgba(0, 0, 0, 0.32);
      cursor: crosshair;
    }
  </style>
</head>
<body>
  <main class="wrap">
    <div class="hud">
      <div id="status">状态：移动鼠标控制挡板，左键发球</div>
      <div id="remain">剩余砖块：0</div>
    </div>
    <canvas id="game" width="960" height="540" aria-label="弹球打砖块第一关"></canvas>
  </main>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const statusEl = document.getElementById("status");
    const remainEl = document.getElementById("remain");

    const W = canvas.width;
    const H = canvas.height;

    const paddle = {
      width: 150,
      height: 16,
      x: W / 2 - 75,
      y: H - 44,
      speedFollow: 0.32
    };

    const levelConfig = {
      rows: 6,
      cols: 11,
      brickW: 74,
      brickH: 24,
      gap: 8,
      offsetTop: 52
    };

    const balls = [];
    const bricks = [];
    const explosions = [];

    let running = false;
    let won = false;
    let lost = false;
    let mouseX = W / 2;
    let lastTime = performance.now();

    const BRICK_COLORS = ["#ff6b6b", "#ffd166", "#06d6a0", "#4dabf7"];

    function createBall(x, y, vx, vy) {
      balls.push({
        x,
        y,
        vx,
        vy,
        r: 8,
        trail: []
      });
    }

    function resetLevel() {
      balls.length = 0;
      bricks.length = 0;
      explosions.length = 0;
      running = false;
      won = false;
      lost = false;

      const totalW = levelConfig.cols * levelConfig.brickW + (levelConfig.cols - 1) * levelConfig.gap;
      const startX = (W - totalW) / 2;

      for (let row = 0; row < levelConfig.rows; row += 1) {
        for (let col = 0; col < levelConfig.cols; col += 1) {
          bricks.push({
            x: startX + col * (levelConfig.brickW + levelConfig.gap),
            y: levelConfig.offsetTop + row * (levelConfig.brickH + levelConfig.gap),
            w: levelConfig.brickW,
            h: levelConfig.brickH,
            alive: true,
            color: BRICK_COLORS[row % BRICK_COLORS.length],
            splitOnHit: row === 0 && col === 0
          });
        }
      }

      statusEl.textContent = "状态：移动鼠标控制挡板，左键发球";
      updateRemainText();
    }

    function updateRemainText() {
      const left = bricks.filter((b) => b.alive).length;
      remainEl.textContent = `剩余砖块：${left}`;
    }

    function launchBall() {
      if (running || won || lost) {
        return;
      }

      createBall(
        paddle.x + paddle.width / 2,
        paddle.y - 10,
        (Math.random() * 2 - 1) * 130,
        -360
      );
      running = true;
      statusEl.textContent = "状态：游戏进行中";
    }

    function restartAfterEnd() {
      if (!won && !lost) {
        return;
      }
      resetLevel();
    }

    function spawnExplosion(x, y, color) {
      const particles = [];
      for (let i = 0; i < 18; i += 1) {
        const angle = (Math.PI * 2 * i) / 18 + Math.random() * 0.35;
        const speed = 60 + Math.random() * 180;
        particles.push({
          x,
          y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 0.42 + Math.random() * 0.25,
          maxLife: 0.42 + Math.random() * 0.25,
          size: 2 + Math.random() * 3.5,
          color
        });
      }
      explosions.push(...particles);
    }

    function resolveBallBrickCollision(ball, brick) {
      const nearestX = Math.max(brick.x, Math.min(ball.x, brick.x + brick.w));
      const nearestY = Math.max(brick.y, Math.min(ball.y, brick.y + brick.h));
      const dx = ball.x - nearestX;
      const dy = ball.y - nearestY;

      if (dx * dx + dy * dy > ball.r * ball.r) {
        return false;
      }

      const overlapLeft = ball.x + ball.r - brick.x;
      const overlapRight = brick.x + brick.w - (ball.x - ball.r);
      const overlapTop = ball.y + ball.r - brick.y;
      const overlapBottom = brick.y + brick.h - (ball.y - ball.r);
      const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

      if (minOverlap === overlapLeft || minOverlap === overlapRight) {
        ball.vx *= -1;
      } else {
        ball.vy *= -1;
      }

      brick.alive = false;
      spawnExplosion(brick.x + brick.w / 2, brick.y + brick.h / 2, brick.color);

      if (brick.splitOnHit) {
        const speed = Math.hypot(ball.vx, ball.vy);
        const baseAngle = Math.atan2(ball.vy, ball.vx);
        const angleOffset = 0.42;
        const newAngle = baseAngle + angleOffset;
        createBall(ball.x, ball.y, Math.cos(newAngle) * speed, Math.sin(newAngle) * speed);
      }

      updateRemainText();
      if (bricks.every((b) => !b.alive)) {
        running = false;
        won = true;
        statusEl.textContent = "状态：胜利！已清空第一关，左键可重开";
      }

      return true;
    }

    function update(dt) {
      const targetX = mouseX - paddle.width / 2;
      paddle.x += (targetX - paddle.x) * paddle.speedFollow;
      paddle.x = Math.max(0, Math.min(W - paddle.width, paddle.x));

      if (running) {
        for (let i = balls.length - 1; i >= 0; i -= 1) {
          const ball = balls[i];
          ball.x += ball.vx * dt;
          ball.y += ball.vy * dt;

          ball.trail.push({ x: ball.x, y: ball.y });
          if (ball.trail.length > 8) {
            ball.trail.shift();
          }

          if (ball.x - ball.r <= 0 && ball.vx < 0) {
            ball.x = ball.r;
            ball.vx *= -1;
          }
          if (ball.x + ball.r >= W && ball.vx > 0) {
            ball.x = W - ball.r;
            ball.vx *= -1;
          }
          if (ball.y - ball.r <= 0 && ball.vy < 0) {
            ball.y = ball.r;
            ball.vy *= -1;
          }

          if (
            ball.x + ball.r >= paddle.x &&
            ball.x - ball.r <= paddle.x + paddle.width &&
            ball.y + ball.r >= paddle.y &&
            ball.y - ball.r <= paddle.y + paddle.height &&
            ball.vy > 0
          ) {
            ball.y = paddle.y - ball.r;
            const hitPos = (ball.x - (paddle.x + paddle.width / 2)) / (paddle.width / 2);
            const angle = hitPos * (Math.PI / 3.2);
            const speed = Math.max(340, Math.hypot(ball.vx, ball.vy));
            ball.vx = Math.sin(angle) * speed;
            ball.vy = -Math.cos(angle) * speed;
          }

          for (const brick of bricks) {
            if (!brick.alive) {
              continue;
            }
            if (resolveBallBrickCollision(ball, brick)) {
              break;
            }
          }

          if (ball.y - ball.r > H + 40) {
            balls.splice(i, 1);
          }
        }

        if (balls.length === 0 && !won) {
          running = false;
          lost = true;
          statusEl.textContent = "状态：失败，左键重新开始第一关";
        }
      }

      for (let i = explosions.length - 1; i >= 0; i -= 1) {
        const p = explosions[i];
        p.life -= dt;
        if (p.life <= 0) {
          explosions.splice(i, 1);
          continue;
        }
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vx *= 0.985;
        p.vy *= 0.985;
      }
    }

    function draw() {
      ctx.clearRect(0, 0, W, H);

      const glow = ctx.createRadialGradient(W * 0.5, -40, 60, W * 0.5, H * 0.2, H * 0.9);
      glow.addColorStop(0, "rgba(135, 206, 250, 0.18)");
      glow.addColorStop(1, "rgba(20, 28, 52, 0)");
      ctx.fillStyle = glow;
      ctx.fillRect(0, 0, W, H);

      for (const brick of bricks) {
        if (!brick.alive) {
          continue;
        }
        ctx.fillStyle = brick.color;
        ctx.fillRect(brick.x, brick.y, brick.w, brick.h);

        ctx.fillStyle = "rgba(255,255,255,0.18)";
        ctx.fillRect(brick.x + 2, brick.y + 2, brick.w - 4, 6);

        if (brick.splitOnHit) {
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.strokeRect(brick.x + 2, brick.y + 2, brick.w - 4, brick.h - 4);
        }
      }

      for (const ball of balls) {
        for (let i = 0; i < ball.trail.length; i += 1) {
          const t = ball.trail[i];
          const alpha = (i + 1) / ball.trail.length;
          ctx.fillStyle = `rgba(255,255,255,${alpha * 0.18})`;
          ctx.beginPath();
          ctx.arc(t.x, t.y, ball.r * (0.45 + alpha * 0.35), 0, Math.PI * 2);
          ctx.fill();
        }

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fill();
      }

      for (const p of explosions) {
        const alpha = p.life / p.maxLife;
        ctx.fillStyle = hexToRgba(p.color, alpha);
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * (0.65 + alpha), 0, Math.PI * 2);
        ctx.fill();
      }

      const paddleGradient = ctx.createLinearGradient(paddle.x, paddle.y, paddle.x, paddle.y + paddle.height);
      paddleGradient.addColorStop(0, "#c8f5ff");
      paddleGradient.addColorStop(1, "#52d3ee");
      ctx.fillStyle = paddleGradient;
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

      ctx.fillStyle = "rgba(255,255,255,0.2)";
      ctx.fillRect(paddle.x + 4, paddle.y + 2, paddle.width - 8, 4);

      if (!running && !won && !lost) {
        const previewX = paddle.x + paddle.width / 2;
        const previewY = paddle.y - 10;
        ctx.fillStyle = "rgba(255,255,255,0.9)";
        ctx.beginPath();
        ctx.arc(previewX, previewY, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      if (won || lost) {
        ctx.fillStyle = "rgba(3,8,20,0.58)";
        ctx.fillRect(0, 0, W, H);

        ctx.textAlign = "center";
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 52px Trebuchet MS";
        ctx.fillText(won ? "YOU WIN" : "GAME OVER", W / 2, H / 2 - 14);
        ctx.font = "22px Trebuchet MS";
        ctx.fillText("左键点击重新开始第一关", W / 2, H / 2 + 34);
      }
    }

    function hexToRgba(hex, alpha) {
      const safeHex = hex.replace("#", "").trim();
      const expanded = safeHex.length === 3
        ? safeHex.split("").map((c) => c + c).join("")
        : safeHex;
      const num = Number.parseInt(expanded, 16);
      const r = (num >> 16) & 255;
      const g = (num >> 8) & 255;
      const b = num & 255;
      return `rgba(${r}, ${g}, ${b}, ${Math.max(0, Math.min(1, alpha))})`;
    }

    function gameLoop(now) {
      const dt = Math.min(0.033, (now - lastTime) / 1000);
      lastTime = now;
      update(dt);
      draw();
      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener("mousemove", (event) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = W / rect.width;
      mouseX = (event.clientX - rect.left) * scaleX;
    });

    canvas.addEventListener("mousedown", (event) => {
      if (event.button !== 0) {
        return;
      }
      if (won || lost) {
        restartAfterEnd();
        return;
      }
      launchBall();
    });

    canvas.addEventListener("contextmenu", (event) => event.preventDefault());

    resetLevel();
    requestAnimationFrame((t) => {
      lastTime = t;
      gameLoop(t);
    });
  </script>
</body>
</html>
