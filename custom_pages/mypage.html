	<!DOCTYPE html>
	<html lang="zh-CN">
	<head>
	    <meta charset="UTF-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	    <title>经典坦克大战 (1985复刻版)</title>
	    <style>
	        body {
	            background-color: #202020;
	            color: #fff;
	            font-family: 'Courier New', Courier, monospace;
	            display: flex;
	            flex-direction: column;
	            align-items: center;
	            justify-content: center;
	            height: 100vh;
	            margin: 0;
	            overflow: hidden;
	        }
	        #game-container {
	            position: relative;
	            border: 4px solid #666;
	            box-shadow: 0 0 20px #000;
	        }
	        canvas {
	            display: block;
	            background-color: #000;
	        }
	        #ui {
	            display: flex;
	            justify-content: space-between;
	            width: 520px; /* Canvas width + padding */
	            margin-bottom: 10px;
	            font-weight: bold;
	            font-size: 18px;
	        }
	        .info-box {
	            background: #333;
	            padding: 5px 10px;
	            border: 1px solid #555;
	        }
	        #start-screen {
	            position: absolute;
	            top: 0;
	            left: 0;
	            width: 100%;
	            height: 100%;
	            background: rgba(0, 0, 0, 0.85);
	            display: flex;
	            flex-direction: column;
	            justify-content: center;
	            align-items: center;
	            z-index: 10;
	        }
	        button {
	            background: #d32f2f;
	            color: white;
	            border: 2px solid #fff;
	            padding: 10px 20px;
	            font-size: 20px;
	            cursor: pointer;
	            font-family: inherit;
	            text-transform: uppercase;
	        }
	        button:hover {
	            background: #b71c1c;
	        }
	        .controls-hint {
	            margin-top: 15px;
	            font-size: 12px;
	            color: #aaa;
	        }
	    </style>
	</head>
	<body>
	    <div id="ui">
	        <div class="info-box">敌军剩余: <span id="enemy-count">20</span></div>
	        <div class="info-box">玩家生命: <span id="lives">3</span></div>
	        <div class="info-box">关卡: 1</div>
	    </div>
	    <div id="game-container">
	        <canvas id="gameCanvas" width="520" height="520"></canvas>
	        <div id="start-screen">
	            <h1 style="color: #ffcc00; text-shadow: 2px 2px #d32f2f;">BATTLE CITY</h1>
	            <button onclick="startGame()">开始游戏</button>
	            <div class="controls-hint">WASD 或 方向键移动 | 空格键 射击</div>
	        </div>
	    </div>
	    <script>
	        const canvas = document.getElementById("gameCanvas");
	        const ctx = canvas.getContext("2d");
	        const startScreen = document.getElementById("start-screen");
	        const enemyDisplay = document.getElementById("enemy-count");
	        const livesDisplay = document.getElementById("lives");
	        // 游戏常量 (致敬FC原版)
	        const TILE_SIZE = 20; // 每个格子大小
	        const ROWS = 26;
	        const COLS = 26;
	        const PLAYER_SPEED = 2;
	        const BULLET_SPEED = 4;
	        const ENEMY_SPEED = 1.5;
	        // 游戏状态
	        let gameInterval;
	        let isGameOver = false;
	        let keys = {};
	        let player;
	        let enemies = [];
	        let bullets = [];
	        let particles = []; // 爆炸效果
	        let map = [];
	        let lives = 3;
	        let enemiesToSpawn = 20;
	        let spawnTimer = 0;
	        let baseActive = true; // 老鹰是否存活
	        // 0:空, 1:砖, 2:钢, 3:草(不阻挡子弹但遮挡视线-这里简化为只阻挡移动), 4:水, 9:老鹰
	        // 模拟经典第一关地图
	        const LEVEL_1_MAP = [
	            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,2,2,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,2,2,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,2,2,1,1,2,2,1,1,2,2,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,2,2,1,1,2,2,1,1,2,2,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0],
	            [0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0],
	            [0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0],
	            [0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0],
	            [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
	            [0,0,0,0,0,0,0,0,0,1,1,9,9,1,1,0,0,0,0,0,0,0,0,0,0,0],
	            [0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0],
	            [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
	        ];
	        // 基础类
	        class Rect {
	            constructor(x, y, w, h) {
	                this.x = x;
	                this.y = y;
	                this.w = w;
	                this.h = h;
	            }
	            intersects(other) {
	                return this.x < other.x + other.w &&
	                       this.x + this.w > other.x &&
	                       this.y < other.y + other.h &&
	                       this.y + this.h > other.y;
	            }
	        }
	        class Bullet extends Rect {
	            constructor(x, y, dir, owner) {
	                super(x, y, 6, 6); // 子弹大小
	                this.dir = dir; // 0:上, 1:右, 2:下, 3:左
	                this.owner = owner; // 'player' or 'enemy'
	                this.speed = BULLET_SPEED;
	                // 修正子弹初始位置到坦克中心
	                if (dir === 0) this.x += 7;
	                if (dir === 1) this.x += 14;
	                if (dir === 2) this.x += 7; this.y += 14;
	                if (dir === 3) this.y += 7;
	            }
	            update() {
	                if (this.dir === 0) this.y -= this.speed;
	                if (this.dir === 1) this.x += this.speed;
	                if (this.dir === 2) this.y += this.speed;
	                if (this.dir === 3) this.x -= this.speed;
	                // 边界检查
	                if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
	                    return false; // 移除
	                }
	                return true; // 保留
	            }
	            draw() {
	                ctx.fillStyle = "#fff";
	                ctx.fillRect(this.x, this.y, this.w, this.h);
	            }
	        }
	        class Tank extends Rect {
	            constructor(x, y, color, type) {
	                super(x, y, TILE_SIZE - 2, TILE_SIZE - 2); // 稍微小一点方便穿过
	                this.color = color;
	                this.type = type; // 'player' or 'enemy'
	                this.dir = 0; // 0:上, 1:右, 2:下, 3:左
	                this.speed = type === 'player' ? PLAYER_SPEED : ENEMY_SPEED;
	                this.cooldown = 0;
	                this.moving = false;
	                this.life = 1;
	            }
	            draw() {
	                // 简单的像素风格坦克绘制
	                ctx.fillStyle = this.color;
	                // 旋转逻辑：为了简单，我们只是画矩形和炮管
	                // 计算炮管位置
	                let gunX = this.x, gunY = this.y, gunW = 4, gunH = 8;
	                let bodyX = this.x, bodyY = this.y, bodyW = this.w, bodyH = this.h;
	                // 中心调整
	                const cx = this.x + this.w/2;
	                const cy = this.y + this.h/2;
	                ctx.save();
	                ctx.translate(cx, cy);
	                ctx.rotate(this.dir * 90 * Math.PI / 180);
	                // 画车身
	                ctx.fillStyle = this.color;
	                ctx.fillRect(-10, -10, 20, 20);
	                // 履带
	                ctx.fillStyle = "#333"; // 履带深色
	                ctx.fillRect(-12, -10, 2, 20); // 左
	                ctx.fillRect(10, -10, 2, 20);  // 右
	                // 炮管
	                ctx.fillStyle = "#ccc";
	                ctx.fillRect(-2, -16, 4, 10); 
	                // 中心盖
	                ctx.fillStyle = this.color === "#f0e68c" ? "#d4af37" : "#fff";
	                ctx.beginPath();
	                ctx.arc(0, 0, 5, 0, Math.PI*2);
	                ctx.fill();
	                ctx.restore();
	            }
	            move(dir, allTanks) {
	                this.dir = dir;
	                this.moving = true;
	                let nextX = this.x;
	                let nextY = this.y;
	                if (dir === 0) nextY -= this.speed;
	                if (dir === 1) nextX += this.speed;
	                if (dir === 2) nextY += this.speed;
	                if (dir === 3) nextX -= this.speed;
	                // 边界碰撞
	                if (nextX < 0 || nextX + this.w > canvas.width || nextY < 0 || nextY + this.h > canvas.height) {
	                    return; // 撞墙不动
	                }
	                // 地图碰撞
	                let r = Math.floor(nextY / TILE_SIZE);
	                let c = Math.floor(nextX / TILE_SIZE);
	                let r2 = Math.floor((nextY + this.h - 1) / TILE_SIZE);
	                let c2 = Math.floor((nextX + this.w - 1) / TILE_SIZE);
	                // 简化的地图碰撞检测 (检查四个角)
	                let blocked = false;
	                for(let i=r; i<=r2; i++) {
	                    for(let j=c; j<=c2; j++) {
	                        if (i>=0 && i<ROWS && j>=0 && j<COLS) {
	                            let tile = map[i][j];
	                            if (tile === 1 || tile === 2 || tile === 4 || tile === 9) { // 砖,钢,水,老鹰
	                                blocked = true;
	                            }
	                        }
	                    }
	                }
	                // 坦克之间碰撞
	                let tempRect = new Rect(nextX, nextY, this.w, this.h);
	                for (let t of allTanks) {
	                    if (t !== this && tempRect.intersects(t)) {
	                        blocked = true;
	                        break;
	                    }
	                }
	                if (!blocked) {
	                    this.x = nextX;
	                    this.y = nextY;
	                } else {
	                    // 如果是敌方坦克，撞墙换向
	                    if (this.type === 'enemy') this.changeDirRandomly();
	                }
	            }
	            shoot() {
	                if (this.cooldown > 0) return;
	                bullets.push(new Bullet(this.x, this.y, this.dir, this.type));
	                this.cooldown = 30; // 冷却帧数
	            }
	            changeDirRandomly() {
	                let dirs = [0, 1, 2, 3];
	                // 稍微智能一点：50%概率随机，50%概率朝向基地或玩家(简化为随机)
	                this.dir = dirs[Math.floor(Math.random() * dirs.length)];
	            }
	        }
	        // 绘图函数
	        function drawMap() {
	            for (let r = 0; r < ROWS; r++) {
	                for (let c = 0; c < COLS; c++) {
	                    let tile = map[r][c];
	                    let x = c * TILE_SIZE;
	                    let y = r * TILE_SIZE;
	                    if (tile === 1) { // 砖
	                        ctx.fillStyle = "#a52a2a";
	                        ctx.fillRect(x+1, y+1, TILE_SIZE-2, TILE_SIZE-2);
	                        // 砖纹理
	                        ctx.fillStyle = "#800000";
	                        ctx.fillRect(x+4, y+4, TILE_SIZE-8, 2);
	                        ctx.fillRect(x+4, y+10, TILE_SIZE-8, 2);
	                    } else if (tile === 2) { // 钢
	                        ctx.fillStyle = "#c0c0c0";
	                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
	                        ctx.fillStyle = "#fff";
	                        ctx.fillRect(x+4, y+4, 12, 12);
	                    } else if (tile === 4) { // 水
	                        ctx.fillStyle = "#0000ff";
	                        ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
	                    } else if (tile === 9) { // 老鹰
	                        if (baseActive) {
	                            ctx.fillStyle = "#ccc"; // 基地背景
	                            ctx.fillRect(x, y, TILE_SIZE*2, TILE_SIZE*2); // 老鹰是2x2
	                            // 画个简单的鹰图案
	                            ctx.fillStyle = "#d32f2f";
	                            ctx.beginPath();
	                            ctx.moveTo(x+10, y+30);
	                            ctx.lineTo(x+30, y+30);
	                            ctx.lineTo(x+20, y+10);
	                            ctx.fill();
	                            ctx.fillStyle = "#ffeb3b";
	                            ctx.font = "12px Arial";
	                            ctx.fillText("★", x+13, y+25);
	                        } else {
	                            // 被毁坏
	                            ctx.fillStyle = "#333";
	                            ctx.fillRect(x, y, TILE_SIZE*2, TILE_SIZE*2);
	                            ctx.fillStyle = "#555";
	                            ctx.beginPath();
	                            ctx.arc(x+20, y+20, 15, 0, Math.PI*2);
	                            ctx.fill();
	                        }
	                    }
	                }
	            }
	        }
	        function createExplosion(x, y) {
	            // 简单的粒子效果
	            for(let i=0; i<8; i++) {
	                particles.push({
	                    x: x, y: y,
	                    vx: (Math.random() - 0.5) * 4,
	                    vy: (Math.random() - 0.5) * 4,
	                    life: 20
	                });
	            }
	        }
	        function drawParticles() {
	            for (let i = particles.length - 1; i >= 0; i--) {
	                let p = particles[i];
	                p.x += p.vx;
	                p.y += p.vy;
	                p.life--;
	                ctx.fillStyle = `rgba(255, 100, 0, ${p.life / 20})`;
	                ctx.fillRect(p.x, p.y, 4, 4);
	                if (p.life <= 0) particles.splice(i, 1);
	            }
	        }
	        // 输入处理
	        window.addEventListener("keydown", e => {
	            keys[e.key] = true;
	            keys[e.code] = true; // 兼容 Space
	        });
	        window.addEventListener("keyup", e => {
	            keys[e.key] = false;
	            keys[e.code] = false;
	        });
	        function resetGame() {
	            // 深拷贝地图
	            map = LEVEL_1_MAP.map(row => [...row]);
	            player = new Tank(9 * TILE_SIZE, 24 * TILE_SIZE, "#f0e68c", 'player');
	            enemies = [];
	            bullets = [];
	            particles = [];
	            lives = 3;
	            enemiesToSpawn = 20;
	            baseActive = true;
	            isGameOver = false;
	            livesDisplay.innerText = lives;
	            enemyDisplay.innerText = enemiesToSpawn;
	            spawnTimer = 0;
	        }
	        function startGame() {
	            startScreen.style.display = 'none';
	            resetGame();
	            if (gameInterval) clearInterval(gameInterval);
	            gameInterval = setInterval(gameLoop, 1000 / 60);
	        }
	        function gameOver(win) {
	            isGameOver = true;
	            clearInterval(gameInterval);
	            startScreen.style.display = 'flex';
	            startScreen.querySelector('h1').innerText = win ? "任务完成!" : "GAME OVER";
	            startScreen.querySelector('button').innerText = "重新开始";
	        }
	        function gameLoop() {
	            // 清屏
	            ctx.fillStyle = "#000";
	            ctx.fillRect(0, 0, canvas.width, canvas.height);
	            drawMap();
	            if (isGameOver) return;
	            // 玩家逻辑
	            let oldX = player.x, oldY = player.y;
	            if (keys["w"] || keys["ArrowUp"]) player.move(0, enemies.concat(player));
	            else if (keys["s"] || keys["ArrowDown"]) player.move(2, enemies.concat(player));
	            else if (keys["a"] || keys["ArrowLeft"]) player.move(3, enemies.concat(player));
	            else if (keys["d"] || keys["ArrowRight"]) player.move(1, enemies.concat(player));
	            if (keys[" "] || keys["Space"]) player.shoot();
	            if (player.cooldown > 0) player.cooldown--;
	            player.draw();
	            // 敌军生成
	            if (enemies.length < 4 && enemiesToSpawn > 0) {
	                spawnTimer++;
	                if (spawnTimer > 120) { // 约2秒生成一个
	                    // 3个出生点: 左上, 中上, 右上
	                    let spawns = [0, 12, 24];
	                    let sx = spawns[Math.floor(Math.random()*3)] * TILE_SIZE;
	                    // 检查出生点是否有坦克，防止重叠
	                    let clear = true;
	                    for(let e of enemies) {
	                        if (Math.abs(e.x - sx) < TILE_SIZE && Math.abs(e.y) < TILE_SIZE) clear = false;
	                    }
	                    if (clear) {
	                        enemies.push(new Tank(sx, 0, "#e0e0e0", 'enemy'));
	                        enemiesToSpawn--;
	                        enemyDisplay.innerText = enemiesToSpawn;
	                        spawnTimer = 0;
	                    }
	                }
	            } else if (enemiesToSpawn === 0 && enemies.length === 0 && baseActive) {
	                gameOver(true);
	            }
	            // 敌军逻辑
	            for (let i = enemies.length - 1; i >= 0; i--) {
	                let e = enemies[i];
	                // 简单AI: 移动
	                if (Math.random() < 0.02) e.changeDirRandomly();
	                e.move(e.dir, enemies.concat(player));
	                // 射击
	                if (Math.random() < 0.015) e.shoot();
	                if (e.cooldown > 0) e.cooldown--;
	                e.draw();
	                // 玩家与敌人碰撞 (同归于尽)
	                if (player.intersects(e)) {
	                    createExplosion(player.x, player.y);
	                    lives--;
	                    livesDisplay.innerText = lives;
	                    if (lives <= 0) {
	                        player.x = -100; // 移出屏幕
	                        gameOver(false);
	                    } else {
	                        // 重置玩家位置
	                        player.x = 9 * TILE_SIZE;
	                        player.y = 24 * TILE_SIZE;
	                        player.dir = 0;
	                    }
	                    createExplosion(e.x, e.y);
	                    enemies.splice(i, 1);
	                }
	            }
	            // 子弹逻辑
	            for (let i = bullets.length - 1; i >= 0; i--) {
	                let b = bullets[i];
	                let active = b.update();
	                b.draw();
	                if (!active) {
	                    bullets.splice(i, 1);
	                    continue;
	                }
	                // 子弹碰撞检测
	                // 1. 地图
	                let c = Math.floor((b.x + 3) / TILE_SIZE);
	                let r = Math.floor((b.y + 3) / TILE_SIZE);
	                if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
	                    let tile = map[r][c];
	                    if (tile === 1) { // 砖
	                        map[r][c] = 0; // 销毁
	                        createExplosion(b.x, b.y);
	                        bullets.splice(i, 1);
	                        continue;
	                    } else if (tile === 2) { // 钢
	                        createExplosion(b.x, b.y); // 声音/火花
	                        bullets.splice(i, 1);
	                        continue;
	                    } else if (tile === 9) { // 老鹰
	                        baseActive = false;
	                        createExplosion(b.x, b.y);
	                        // 强制刷新该块区域为爆炸状态
	                        map[r][c] = 0; // 虽然视觉上画了，但逻辑上变成空地，或者保持9但在drawMap里根据baseActive画
	                        bullets.splice(i, 1);
	                        gameOver(false);
	                        continue;
	                    }
	                }
	                // 2. 坦克
	                if (b.owner === 'player') {
	                    for (let j = enemies.length - 1; j >= 0; j--) {
	                        if (b.intersects(enemies[j])) {
	                            createExplosion(enemies[j].x, enemies[j].y);
	                            enemies.splice(j, 1);
	                            bullets.splice(i, 1);
	                            break;
	                        }
	                    }
	                } else {
	                    if (b.intersects(player)) {
	                        createExplosion(player.x, player.y);
	                        lives--;
	                        livesDisplay.innerText = lives;
	                        bullets.splice(i, 1);
	                        if (lives <= 0) {
	                            player.x = -100;
	                            gameOver(false);
	                        } else {
	                            player.x = 9 * TILE_SIZE;
	                            player.y = 24 * TILE_SIZE;
	                        }
	                    }
	                }
	            }
	            drawParticles();
	        }
	    </script>
	</body>
	</html>

